package diego.ufu.workloadoutput.main;
import java.util.ArrayList;
import java.util.List;

import diego.ufu.workloadoutput.calculus.CalculusModule;
import diego.ufu.workloadoutput.calculus.FrequencyOperationCalculus;
import diego.ufu.workloadoutput.calculus.QuantitiesCalculus;
import diego.ufu.workloadoutput.calculus.SizeFrequencyCalculus;
import diego.ufu.workloadoutput.calculus.SmartTimeRetentionCalculus;
import diego.ufu.workloadoutput.calculus.TotalTimeCalculus;


/**
 * Main class of the WC_Analysis.
 * 
 * It receives a set of malloc/free files generated by the DebugMalloc.
 * It reads once from each file and analyzes its data generating a report.
 * 
 * WC_Analysis uses the name of the malloc/free files to identify each 
 * replication of the experiment. Therefore, the name of the files generated 
 * by DebugMalloc should be compatible with this program (see inputFileNameFormat 
 * variable and generateFileName() method). 
 * 
 * DEFAULT:
 * 	The files should come with 
 * 		[nameOfApplication_malloc_replication.csv] for allocation data
 * 		[nameOfApplication_malloc_replication.csv] for deallocation data
 * 
 * Eg.:
 * 		mySQL_malloc_1.csv, mySQL_malloc_2.csv, mySQL_malloc_3.csv ... 
 * 		mySQL_free_1.csv, mySQL_free_2.csv, mySQL_free_3.csv ...
 * 
 * CUSTOMIZATION:
 * 		Look into every @Parameter tag to check what kinds of customization  
 * you can apply to the WC_Analysis.
 * 
 * CAUTION: 
 * 		This program was created to analyze data from DebugMalloc.
 * 		Therefore, the content of the files should not be changed from its default if 
 * 	you want to keep the whole structure of WC_Analysis.
 * 		To add a new parameter into the files (like function return pointer) 
 *  you will have to customize other classes as well, including the reader (to read the new data), 
 *  beans (data in memory) and the analysis (calculus) classes.
 * 
 * (+) ADDING A NEW EXPERIMENT:
 * 		For each experiment to be analyzed by the WC_Analysis you should
 * add an {@link Experiment} object to list of experiments. Each {@link Experiment} must contain 
 * the path of the input and output files (see addExperiments() for an example). You can use
 * {@link ExperimentBuilder} for a more friendly builder interface.
 * 
 * (+) ADDING A NEW ANALYSIS:
 * 		In order to create a new analysis you must implement the interface {@link CalculusModule}.
 * After the implementation you should add it to the {@link StatisticAnalysis} object 
 * (see addCalculusModule() for an example).
 * 
 * (+) REMOVING/DISABLING AN ANALYSIS:
 * 		Just comment the line in addCalculusModule() of the correspondent analysis.
 * The analysis is not performed if not added into the {@link StatisticAnalysis} object. 
 * 
 * (+) INCREASING/DECREASING the number of replications:
 * 		Just change the variables REPLICATION_BEGIN and REPLICATION_END.
 * 
 * 
 * @author Diego Costa
 *
 */
public class Main {

	/**
	 * @Parameter
	 * Index of the replications analyzes
	 * 	[REPLICATION_BEGIN, REPLICATION_END]
	 * This should be mapped in the name of the file (see inputFileNameFormat)
	 */
	private static final int REPLICATION_BEGIN = 2;
	private static final int REPLICATION_END = 30;
	
	/** 
	 * Input File Format
	 * Current format = path + fileName + _ + replication + .csv 
	 *					(eg. path = "C:\" | filename = "MySQL_malloc" | 3 Replications
	 *					C:\MySQL_malloc_1.csv, C:\MySQL_malloc_2.csv, C:\MySQL_malloc_3.csv)
	 *
	 * See Main.generateFileName method to check how this is used
	 */
	private static String inputFileNameFormat = "%s" + "%s" + "_" + "%s" + ".csv";
	
	static FileReader reader;
	static StatisticAnalysis analysis;
	static List<Experiment> experiments = new ArrayList<>();
	
	private static String pathFolder;
	
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
			
		 addExperiments();
		 
		 analysis = new StatisticsAnalysisImpl();
		 addCalculusModule();
		 
		 for(Experiment exp : experiments) {
			 
			 System.out.println("[INFO] Starting the Workload Output Program");
			 System.out.println("[INFO] Parameters");
			 System.out.println("[INFO] Start Replications:" + REPLICATION_BEGIN);
			 System.out.println("[INFO] End Replications: " + REPLICATION_END);
			 System.out.println("[INFO] Input Path Folder: " + exp.getPath());
			 System.out.println("[INFO] Output Path File: " + exp.getOutputFile());
			 System.out.println("[INFO] Malloc File Pattern: " + exp.getMallocFileName());
			 System.out.println("[INFO] Free File Pattern: " + exp.getFreeFileName());
			 
			 try {
				 // Measuring the time spent in the analysis
				 long startTime = System.currentTimeMillis();
				 // Execute the analysis
				 executeAnalysis(exp);
				 long endTime = System.currentTimeMillis();
				 
				 System.out.println("[INFO] Time elapsed (seconds): " 
						 			+ ((endTime - startTime) / 1000));
			 } catch (Exception e) {
				 e.printStackTrace();
			 }
		 
		 }
			
	}

	private static void executeAnalysis(Experiment exp) throws Exception {
		
		 reader = new FileReaderImpl();
		 pathFolder = exp.getPath();

		 StringBuilder programReport = new StringBuilder();
		 programReport.append(analysis.printHeader());
		 
		 System.out.println("[INFO] Reading: ");
		 System.out.print("     ");
		 
		 // Get all the replications
		 for(int i = REPLICATION_BEGIN; i <= REPLICATION_END; i++) {
			 System.out.print(" | " + i + " | ");
			 
			 // Generate the malloc/free file name pattern
			 String mallocFileName = generateFileName(exp.getMallocFileName(), i);
			 String freeFileName = generateFileName(exp.getFreeFileName(), i);
			 
			 // Read both malloc/free file
			 MallocInfo info = reader.loadFile(mallocFileName, 
					 freeFileName);
			 
			 // Generate the Report
			 StringBuilder report = analysis.generateReport(info);
			 
			 // Add to the report 
			 programReport.append(report);
		 }
		 
		 System.out.println("[INFO] Writing the output file...");
		 // Write the into in the output file
		 Utils.writeFile(exp.getOutputFile(), programReport);
		
	}
	
	/**
	 * Generate the FileName of the malloc/free operations based on the
	 * inputNameFormat variable
	 * 
	 */
	private static String generateFileName(String fileName, int replicationID) {
		return String.format(inputFileNameFormat, pathFolder, fileName, replicationID);
	}


	/**
	 * Here I add the INFO about each experiment that should be analyzed
	 * 
	 */
	private static void addExperiments() {
		
		/**
		 * @Parameter
		 * Here you should add the experiment that should be analyzed with the 
		 * four specified parameters (path, mallocFile, freeFile, outputFilePath)
		 * 
		 */
		// Example: MySQL
		experiments.add(new ExperimentBuilder()
				.withPath("D:/UFU/WC - MySQL/")
				.withMallocFileName("mySQL_malloc")
				.withFreeFileName("mySQL_free")
				.withOutputFilePath("D:/UFU/WC - Result/MySQL_Result.csv")
				.build());
	}

	/**
	 * In this method we decide WHICH analyze should be performed
	 */
	private static void addCalculusModule() {
		
			/**
			 * @Parameter
			 * Retrieves the total time of the experiment
			 * Total Time Experiment = time from the first to the last 
			 * dynamic memory operation (alloc/dealloc)
			 */
			analysis.addCalculusModule(new TotalTimeCalculus());
		
		
			/**
			 * @Parameter
			 * Analyzes the quantities of allocations/deallocations
			 *  # of Allocations
			 *	# of Deallocations                    
			 *	# of NULL Deallocations                
			 *	% non-deallocated allocations  -> (alloc - dealloc)/ alloc       
			 *	Total of Requested Memory  
			 *  Average Size of Allocation    
			 */
			analysis.addCalculusModule(new QuantitiesCalculus());
			
			/**
			 * @Parameter
			 * Analyzes the frequency of the allocation operation (malloc, realloc, cealloc)
			 * 	# malloc() 
			 *	# calloc() 
			 *	# realloc()
			 *	% malloc() 
			 *	% calloc() 
			 *	% realloc()
			 */
			analysis.addCalculusModule(new FrequencyOperationCalculus());
			
			/**
			 * @Parameter
			 * Analyzes the frequency of the allocated sizes by Size Category (SC)
			 * 	Frequency by SC (see SizeCategory class)
			 *  Distinct allocated sizes by SC (see SizeCategory class)
			 *  10 Most allocated sizes
			 *  Number of distinct size allocations (total)
			 */
			analysis.addCalculusModule(new SizeFrequencyCalculus());
		
			/**
			 * @Parameter
			 * Analyzes the Retention Time (RT) of the allocations
			 * For each TimeRetentionCategory (see TimeRetentionCategory class) it provides:
			 *  Average RT
             *  RT Variance 
             *  RT Standard Deviation
             *  Minimum RT
             *  Maximum RT
			 */
			analysis.addCalculusModule(new SmartTimeRetentionCalculus());
			
			/**
			 * @Parameter
			 * This is a temporal analyzes between allocation/deallocation
			 * This should not be used with the other analyzes as it brings 
			 * a huge amount of data (basically all alloc and dealloc sorted 
			 * by time)
			 */
			//analysis.addCalculusModule(new AllocDeallocBehaviorCalculus());
			
			/**
			 * @Parameter
			 * Analyzes the sizes frequency and returns a map containing
			 * 	[allocation size = # of allocations]
			 * This should not be used with the other analyzes and should be executed 
			 * per replication as it brings two columns with [size] [# of allocations]
			 *  
			 *	  
			 */
			//analysis.addCalculusModule(new AllSizeFrequencyCalculus());
		
	}

}
